program fill_array;

{ Наибольшее число элементов в массиве }
const nmax = 16384;

var 
    { Массив из целых чисел }
    a: array [1..nmax] of integer;
    { Переменная, которая будет следить за размером массива }
    N: integer;

{ Подпрограмма, которая устанавливает начальные значения массива
    в случайном порядке и фиксирует размер массива }
procedure init_array(n_elements: integer; max_val: integer);
var
    i: integer;
begin
    N := n_elements;
    for i := 1 to N do
        { Заполним массив случайными числами от 1 до N в цикле }
        a[i] := random(max_val) + 1
end;

{ Простая подпрограмма печати массива на экран, целая строчка тратится
    на одиин элемент }
procedure print_array;
var
    i: integer;
begin
    for i := 1 to N do
        writeln('a[', i, '] = ', a[i]);
end;

{ Подпрограмма печати массива на экран в расчёте на то что в массиве
    каждый элемент меньше сотни, тогда в строку поместится 24 элемента }
procedure write_array;
var
    i: integer;
begin
    for i := 1 to N do
        write(a[i]:3);
    { После вывода всех символов надо обозначить конец строки,
        иначе последующий вывод на экран испортится }
    writeln
end;

{ Подпрограмма, которая рисует горизонтальную линию, длина зависит
    от заданного параметра len; линия займёт 3*len символов }
procedure hline(len: integer);
var
    i: integer;
begin
    for i := 1 to len do
        write('---');
    { После вывода всех символов надо обозначить конец строки,
        иначе последующий вывод на экран испортится }
    writeln
end;

{ Подпрограмма, которая печатает заголовок таблицы на экран }
procedure write_header;
var
    i: integer;
begin
    write(' i ');
    for i := 1 to N do
        write(i:3);
    writeln;
    hline(N + 1)
end;

{ Подпрограмма печати начального массива }
procedure present_array;
begin
    write_header;
    write(' 1:');
    write_array
end;

{ Подпрограмма сортировки массива "a" простыми включениями.
  Представьте, что вам надо отсортировать игральные карты.  Всю колоду можно
  разбить на две части на каждом шаге алгоритма: первая, сортированная часть,
  и вторая часть, которую только предстоит сортировать. Из второй части
  выберите первую карту и вставьте её в правильном месте в первую часть. В
  самом начале сортированная часть будет состоять только из первой карты, а
  вторая и последующие будут находится в несортированой колоде. В процессе
  работы алгоритма несортированная часть будет уменьшаться до тех пор пока она
  совсем не исчзнет --- в этот момент алгоритм остановится. }
procedure straight_insertion;
var
    i, j: integer;
    x: integer;
begin
    { i --- это индекс массива, который будет разделять сортированную и 
    несортированную части. В самом начале i = 2, и каждый раз i увеличивается
    на единицу, пока не достигнет конца массива: i = N. Цикл for подходит для
    такого случая идеально. }
    for i := 2 to N do
    begin
        { x --- временная переменная, она хранит значение той самой
        <<карты>>, с которой мы сравниваем сортированную колоду }
        x := a[i];
        { j --- это ещё один индекс, для сортированной части. J будет
        меняться от i - 1 вниз до единицы }
        j := i - 1;
        { Начинается вложенный цикл. Мы будем уменьшать j на единицу на
        каждом шаге, поэтому надо проверить условие что j всё ещё
        указывает на элементы массива. Также, в силу того, что элементы
        нижней части уже сортированы, нам нет смысла проверять их все,
        нам нужно найти ровно то место, куда нужно поместить нашу <<карту>>.}
        while (x < a[j]) and (j >= 1) do
        begin
            { Передвигаем элементы (кстати, в этот момент a[i] затирается) }
            a[j + 1] := a[j];
            { Уменьшаем счётчик }
            j := j - 1;
        end;
        { В конце проходки по сортированной колоде мы вставляем на найденное
        место (а это j + 1) нашу <<карту>> }
        a[j + 1] := x;
        { Следующие команды не являются частью алгоритма, они нужны лишь
        для иллюстрации его работы }
        write(i:2, ':');
        write_array
    end
end;

begin
    { Пусть каждый раз случайная последовательность будет новой }
    randomize;
    { Создадим массив из 8 элементов, каждый из которых не больше 99 }
    init_array(8, 99);
    { Выведем на экран оригинальный массив вместе с <<шапкой>> }
    present_array;
    { Запустим алгоритм }
    straight_insertion;
    { Подведём черту под табличкой }
    hline(N + 1);
    readln
end.
